/* ------------------------------------------
 * translate Helper
 *------------------------------------------- */
// Doc about message format : http://userguide.icu-project.org/formatparse/messages
import { parse } from 'intl-messageformat-parser';
import * as fs from 'fs';
import { sync as globSync } from 'glob';
import { sync as mkdirpSync } from 'mkdirp';
import isEmpty from 'lodash/isEmpty';
import rimraf from 'rimraf';

const AVAILABLE_LOCALES = require('../constants').LANGUAGES;

const ORIGIN_PATH = './i18n/origin';
const EXPORT_DIR = './src/state/locales';
const DOC_DIR = './i18n/documentation';
const DOC_FILE = `${DOC_DIR}/all.json`;

const makeLocalePath = locale => `${EXPORT_DIR}/${locale}.json`;
const makeGlob = path => `${path}/**/*.json`;

/**
 * Delete origin content on error
 * @param cb
 */
const emptyOriginDirectory = cb => {
  rimraf(`${ORIGIN_PATH}/*`, () => {
    cb.call(null);
  });
};

/**
 * Load keys generated by Intl
 * @returns {{}}
 */
const loadOriginKeys = () => {
  const files = globSync(makeGlob(ORIGIN_PATH));
  if (!files || files.length < 1) {
    throw new Error('Empty localization index');
  }
  return files.map(filename => fs.readFileSync(filename, 'utf8'))
    .map(file => JSON.parse(file));
};

/**
 * Extract message map from origin export
 * @param all
 * @returns {{}}
 */
const extractAllMessages = all => all.reduce((collection, descriptors) => ({
  ...collection,
  ...descriptors.reduce((acc, item) => {
    if (Object.prototype.hasOwnProperty.call(collection, item.id)) {
      emptyOriginDirectory(() => {
        throw new Error(`Duplicate message id: ${item.id}`);
      });
    }
    return {
      ...acc,
      [item.id]: {
        ...item,
      },
    };
  }, {}),
}), {});

/**
 * Inflate extracted values from intl API to a human readable mapper
 * @param mapper
 */
const applyDefaultLocaleKeys = mapper => Object.keys(mapper).reduce((acc, next) => ({
  ...acc,
  [next]: {
    ...mapper[next],
    locales: AVAILABLE_LOCALES.reduce((prev, curr) => ({
      ...prev,
      [curr]: mapper[next].defaultMessage,
    }), {}),
  },
}), {});

/**
 * Load human localized keys
 * @returns {{}}
 */
const loadFinalKeys = () => {
  if (fs.existsSync(DOC_FILE)) {
    return JSON.parse(fs.readFileSync(DOC_FILE, 'utf-8'));
  }
  return {};
};

/**
 * Merge extracted and human keys
 * @param generated
 * @param humanized
 */
const mergePreviousAndCurrent = (generated, humanized) =>
  Object.keys(generated).reduce((acc, id) => ({
    ...acc,
    [id]: {
      ...generated[id],
      locales: Object.keys(generated[id].locales)
        .reduce((col, locale) => ({
          ...col,
          [locale]: humanized[id] && humanized[id].locales[locale]
            ? humanized[id].locales[locale]
            : generated[id].locales[locale],
        })
          , {}),
    },
  }), {});

/**
 * Export locales to allow the app to translate labels
 * @param mapper
 */
const exportLocales = mapper => {
  mkdirpSync(EXPORT_DIR);
  AVAILABLE_LOCALES.forEach(locale => {
    console.log(`Export for locale ${locale}`); // eslint-disable-line
    const localizedKeys = Object.keys(mapper)
      .reduce((acc, id) => ({
        ...acc,
        [id]: mapper[id].locales[locale],
      }), {});
    fs.writeFileSync(
      makeLocalePath(locale),
      JSON.stringify(localizedKeys, null, 2)
    );
  });
};

export default function exportTranslations() {
  console.log('Start building translation'); // eslint-disable-line
  mkdirpSync(DOC_DIR);
  const inflated = applyDefaultLocaleKeys(extractAllMessages(loadOriginKeys()));
  const humanized = loadFinalKeys();
  let finalResult = inflated;
  if (!isEmpty(humanized)) {
    finalResult = mergePreviousAndCurrent(inflated, humanized);
  }
  exportLocales(finalResult);
  console.log('Export final documentation'); // eslint-disable-line
  fs.writeFileSync(
    DOC_FILE,
    JSON.stringify(finalResult, null, 2)
  );
  console.log('Translation build finished'); // eslint-disable-line
}
